from PyQt6.QtWidgets import QMainWindow, QDockWidget, QWidget, QVBoxLayout, QLabel, QScrollArea, QFrame
from PyQt6.QtCore import Qt
import logging

from core.state_manager import StateManager
from core.data_loader import DataLoader
from core.logic_engine import LogicEngine
from .map_widget import MapWidget
from .dock_title_bar import DockTitleBar
from .inventory_widgets import ToolsWidget, ScenarioWidget
from .menu_ribbon import MenuRibbon
from utils.constants import STATE_ORDER
from .widgets.items_widget import ItemsWidget
from .widgets.characters_widget import CharactersWidget
from .widgets.maiden_widget import MaidenWidget
from .widgets.hint_widget import HintWidget
from .dialogs.item_search_dialog import ItemSearchDialog
from PyQt6.QtWidgets import QMenu

class MainWindow(QMainWindow):
    def __init__(self, state_manager, data_loader, logic_engine, data_listener):
        super().__init__()
        self.state_manager = state_manager
        self.data_loader = data_loader
        self.logic_engine = logic_engine
        self.data_listener = data_listener
        
        self.setWindowTitle("Lufia 2 Auto Tracker v1.4")
        self.resize(1024, 768)
        
        # --- Menu Ribbon ---
        self.menu_ribbon = MenuRibbon()
        self.setMenuWidget(self.menu_ribbon) # Use setMenuWidget for custom QWidget ribbon
        self._connect_menu_signals()

        self._setup_ui()
        self._connect_signals()
        
        # Connect Listener Signals to UI Feedback
        self.state_manager.auto_update_received.connect(self._on_auto_update_received)

        self._active_search_dialogs = {}

        # Initial Refresh to apply Logic
        self._refresh_all()

    def _setup_ui(self):
        """Initializes the main UI layout."""
        # For now, just a wrapper around the docking setup
        self._setup_docking_ui()

    def _connect_menu_signals(self):
        # Auto Toggle
        self.menu_ribbon.auto_toggled.connect(self._handle_auto_toggle)
        
        # Font Toggle
        self.menu_ribbon.font_adj_toggled.connect(self._toggle_font_controls)
        self.menu_ribbon.header_color_requested.connect(self._pick_header_color)
        
        # Sync Requests
        self.menu_ribbon.sync_requested.connect(self._handle_sync_request)
        
        # Save/Load/Reset
        self.menu_ribbon.reset_requested.connect(self._handle_reset)
        self.menu_ribbon.save_requested.connect(self._handle_save)
        self.menu_ribbon.load_requested.connect(self._handle_load)

    def _toggle_font_controls(self, visible):
        # Iterate over all dock widgets
        for dock in self.findChildren(PersistentDockWidget):
            dock.title_bar.set_font_controls_visible(visible)

    def _pick_header_color(self):
        from PyQt6.QtWidgets import QColorDialog
        color = QColorDialog.getColor(initial=Qt.GlobalColor.darkGray, parent=self, title="Pick Header Color")
        if color.isValid():
            hex_color = color.name()
            for dock in self.findChildren(PersistentDockWidget):
                dock.title_bar.set_header_color(hex_color)

    def _handle_reset(self):
        self.state_manager.reset_overrides()

    def _handle_save(self):
        from PyQt6.QtWidgets import QFileDialog
        path, _ = QFileDialog.getSaveFileName(self, "Save Tracker State", "", "JSON Files (*.json)")
        if path:
            try:
                self.state_manager.save_state(path)
            except Exception as e:
                logging.error(f"Save Failed: {e}")

    def _handle_load(self):
        from PyQt6.QtWidgets import QFileDialog
        path, _ = QFileDialog.getOpenFileName(self, "Load Tracker State", "", "JSON Files (*.json)")
        if path:
            try:
                self.state_manager.load_state(path)
                self._refresh_all()
            except Exception as e:
                logging.error(f"Load Failed: {e}")

    def _handle_auto_toggle(self, active: bool):
        """
        Auto: Full tracking.
        Active = Start Listening.
        Inactive = Stop Listening.
        """
        if active:
            if self.data_listener.start_listening():
                print("Auto Tracking Started")
            else:
                # Failed to start
                self.menu_ribbon._toggle_auto() # Revert UI
        else:
            self.data_listener.stop_listening()
            print("Auto Tracking Stopped")

    def _handle_sync_request(self, category):
        """
        Sync: Fetch snapshot.
        If Auto is OFF: Start Listener -> Wait for 1 update -> Stop.
        If Auto is ON: Force update (Listener is already running, so maybe we just wait? Or request?)
        """
        print(f"Sync Requested: {category}")
        # Logic depends on C# helper protocol.
        # Assuming helper sends data periodically? 
        # If so, just waiting is enough?
        # User said "Sync... overwriting user input".
        
        # For now, if we are NOT listening, we should momentarily listen.
        if not self.data_listener.server.isListening():
             if self.data_listener.start_listening():
                 # We need to know this is a "One Shot".
                 # We can flag it?
                 self._is_syncing = True
        else:
             # Already listening.
             pass

    def _on_auto_update_received(self, payload):
        """Called when StateManager processes an update."""
        # If we were doing a one-shot sync, stop now.
        if getattr(self, '_is_syncing', False):
            self.data_listener.stop_listening()
            self._is_syncing = False
            print("Sync Snapshot Complete")
        
        # If Auto is active, we keep listening.
        # Payload processing happened in StateManager.
        
        # Just refresh the UI to show new states
        self._refresh_all()

    def _setup_docking_ui(self):
        # Allow nested docks
        self.setDockOptions(QMainWindow.DockOption.AllowNestedDocks | QMainWindow.DockOption.AnimatedDocks)

        # --- Items Dock (Left, Top) ---
        self.items_dock = PersistentDockWidget("Items / Spells", self)
        self.items_widget = ItemsWidget(self.state_manager)
        self.items_dock.setWidget(self.items_widget)
        self.items_dock.setMinimumSize(100, 100)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.items_dock)

        # --- Hints Dock (Left, Bottom) ---
        self.hints_dock = PersistentDockWidget("Hints", self)
        self.hint_widget = HintWidget()
        self.hints_dock.setWidget(self.hint_widget)
        self.hints_dock.setMinimumSize(100, 100)
        self.addDockWidget(Qt.DockWidgetArea.LeftDockWidgetArea, self.hints_dock)
        
        # --- Characters Dock (Right -> Middle Column) ---
        # We start by adding it to Right Area
        self.chars_dock = PersistentDockWidget("Characters", self)
        self.characters_widget = CharactersWidget(self.data_loader, self.state_manager)
        self.chars_dock.setWidget(self.characters_widget)
        self.chars_dock.setMinimumSize(100, 150)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.chars_dock)
        
        # --- Tools Dock ---
        self.tools_dock = PersistentDockWidget("Tools", self)
        self.tools_widget = ToolsWidget(self.data_loader)
        self.tools_dock.setWidget(self.tools_widget)
        self.tools_dock.setMinimumSize(100, 60)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.tools_dock)

        # --- Maidens Dock ---
        self.maidens_dock = PersistentDockWidget("Maidens", self)
        self.maiden_widget = MaidenWidget(self.data_loader, self.state_manager)
        self.maidens_dock.setWidget(self.maiden_widget)
        self.maidens_dock.setMinimumSize(100, 60)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.maidens_dock)
        
        # --- Keys Dock ---
        self.scenario_dock = PersistentDockWidget("Keys", self)
        self.scenario_widget = ScenarioWidget(self.data_loader)
        self.scenario_dock.setWidget(self.scenario_widget)
        self.scenario_dock.setMinimumSize(100, 80)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.scenario_dock)
        
        # --- Map Dock (Far Right) ---
        self.map_dock = PersistentDockWidget("World Map", self)
        self.map_widget = MapWidget(self.data_loader)
        self.map_dock.setWidget(self.map_widget)
        self.map_dock.setMinimumSize(200, 200)
        self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, self.map_dock)
        
        # 3-Column Layout Construction:
        # 1. Left is already Items & Hints. Split them Vertical.
        self.splitDockWidget(self.items_dock, self.hints_dock, Qt.Orientation.Vertical)
        
        # 2. Right Side: We want [Mid Col] [Map].
        # Currently everything is in "Right".
        # We split Chars (Mid) and Map (Right) Horizontally.
        self.splitDockWidget(self.chars_dock, self.map_dock, Qt.Orientation.Horizontal)
        
        # 3. Build Middle Column (under Chars).
        self.splitDockWidget(self.chars_dock, self.tools_dock, Qt.Orientation.Vertical)
        self.splitDockWidget(self.tools_dock, self.maidens_dock, Qt.Orientation.Vertical)
        self.splitDockWidget(self.maidens_dock, self.scenario_dock, Qt.Orientation.Vertical)
        
        # 4. Resize Logic
        # Left (Items) : Mid (Chars) : Right (Map) width ratio
        # Vertically in Mid: Chars > Keys > Tools/Maidens
        
        # Set specific Widths by resizeDocks?
        # resizeDocks only works for docks in same splitter.
        # It's complex. Let's try setting stretch factors or just verify this structure is "preferred".
        
        # Re-apply the "Fluid" policy to allow shrinking
        for dock in [self.items_dock, self.hints_dock, self.chars_dock, self.tools_dock, 
                     self.maidens_dock, self.scenario_dock, self.map_dock]:
             from PyQt6.QtWidgets import QSizePolicy
             policy = QSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
             policy.setVerticalStretch(1)
             policy.setHorizontalStretch(1)
        # Re-apply the "Fluid" policy to allow shrinking
        for dock in [self.items_dock, self.hints_dock, self.chars_dock, self.tools_dock, 
                     self.maidens_dock, self.scenario_dock, self.map_dock]:
             from PyQt6.QtWidgets import QSizePolicy
             policy = QSizePolicy(QSizePolicy.Policy.Preferred, QSizePolicy.Policy.Preferred)
             policy.setVerticalStretch(1)
             policy.setHorizontalStretch(1)
             dock.setSizePolicy(policy)

        # Give Map more stretch
        self.map_dock.sizePolicy().setHorizontalStretch(3)
        self.characters_widget.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Ignored)


        # Give Map more stretch
        self.map_dock.sizePolicy().setHorizontalStretch(3)
        self.characters_widget.setSizePolicy(QSizePolicy.Policy.Ignored, QSizePolicy.Policy.Ignored)  # Allow shrinking



    def _connect_signals(self):
        # State Manager Signals -> UI Updates
        self.state_manager.location_changed.connect(self.map_widget.update_dot_color)
        self.state_manager.player_position_changed.connect(self.map_widget.update_player_position)
        # Inventory Widgets connect themselves
        self.tools_widget.connect_signals(self.state_manager)
        self.scenario_widget.connect_signals(self.state_manager)
        
        # Logic Loop Trigger (Inventory Change -> Refresh All)
        self.state_manager.inventory_changed.connect(lambda _: self._refresh_all())
        
        # UI Signals -> State Manager Overrides
        self.map_widget.location_clicked.connect(self._handle_location_click)
        self.map_widget.location_right_clicked.connect(self._handle_location_right_click)

        # Character Signals
        self.state_manager.character_assigned.connect(self._on_character_assigned)
        self.state_manager.character_unassigned.connect(self.map_widget.remove_character_sprite)
        self.state_manager.character_changed.connect(lambda n, o: self.characters_widget.refresh_state())

    def _refresh_all(self):
        """Re-runs logic engine and pushes updates."""
        # Get Accessibility Map
        accessibility = self.logic_engine.calculate_accessibility(self.state_manager.inventory)
        
        # Current Location States (Overrides + Cleared)
        current_loc_states = self.state_manager.locations
        
        # Update every dot on the map
        locations_data = self.data_loader.get_locations() # {name: coords}
        for name in locations_data.keys():
            is_accessible = accessibility.get(name, False)
            
            # Check if this location is "cleared" in the state
            is_cleared = (current_loc_states.get(name) == "cleared")
            
            # Determine color
            final_color = self.logic_engine.determine_color(name, is_accessible, is_cleared)
            
            # Use StateManager's effective state if present
            effective_state = current_loc_states.get(name)
            if effective_state:
                final_color = effective_state
            
            # Tooltip Info
            tooltip_text = name
            if not is_accessible and final_color == "not_accessible":
                # Get missing info
                reqs = self.logic_engine.get_missing_requirements(name, self.state_manager.inventory)
                if reqs:
                    req_str = " OR ".join(reqs)
                    tooltip_text += f"\nRequires: {req_str}"
            
            self.map_widget.update_dot_color(name, final_color)
            self.map_widget.update_dot_tooltip(name, tooltip_text)

    def _handle_location_click(self, name):
        """User clicked a dot: Cycle the state (Manual Override)."""
        current_state = self.state_manager.locations.get(name)
        
        cycle_order = list(STATE_ORDER)
        if name in self.data_loader.get_cities():
             cycle_order = ["city"]
        else:
             cycle_order = ["not_accessible", "fully_accessible", "cleared"]

        if not current_state or current_state not in cycle_order:
             new_state = cycle_order[0]
        else:
             idx = cycle_order.index(current_state)
             new_state = cycle_order[(idx + 1) % len(cycle_order)]
                
        self.state_manager.set_manual_location_state(name, new_state)

    def _handle_location_right_click(self, name):
        """Show Context Menu."""
        logging.info(f"Right clicked {name}")
        
        cities = self.data_loader.get_cities()
        if name in cities:
            self._open_item_search(name)
        else:
            self._open_character_assignment(name)

    def _open_character_assignment(self, location_name):
        menu = QMenu(self)
        menu.setTitle(f"Assign to {location_name}")
        
        # Get all chars
        chars_data = self.data_loader.load_json("characters.json")
        sorted_names = sorted(chars_data.keys())
        
        # Filter: which are available? logic v1.3: "not active and not colored"
        # In our state manager: active_characters = {name: bool}
        active_chars = self.state_manager.active_characters
        
        for char in sorted_names:
            if not active_chars.get(char, False):
                action = menu.addAction(char)
                action.triggered.connect(lambda c, ch=char: self.state_manager.assign_character_to_location(location_name, ch))
        
        # Option to Remove existing?
        existing = self.state_manager.get_character_at_location(location_name)
        if existing:
            menu.addSeparator()
            rem_action = menu.addAction(f"Remove {existing}")
            rem_action.triggered.connect(lambda: self.state_manager.remove_character_assignment(location_name))

        menu.exec(self.map_widget.cursor().pos())

    def _on_character_assigned(self, location, name):
        # Resolve path
        chars_data = self.data_loader.load_json("characters.json")
        rel_path = chars_data[name]["image_path"]
        full_path = self.data_loader.resolve_image_path(rel_path)
        
        self.map_widget.add_character_sprite(location, name, full_path)


    def _open_item_search(self, location_name):
        # Parent=None to allow independent window (Taskbar entry, Alt-Tab, free movement)
        dlg = ItemSearchDialog(location_name, self.data_loader, parent=None)
        dlg.item_added.connect(self._on_shop_item_added)
        
        # Position at cursor for "Context Menu" feel, but ensure it fits on screen?
        # Default center of parent is also fine. 
        # User said "appears in a weird spot" for the context menu.
        # Let's just let Qt handle centering or position near cursor.
        # dlg.move(self.map_widget.cursor().pos()) 
        
        dlg.exec() # Blocking
        
        # Cleanup
        dlg.deleteLater()

    # removed _on_search_dialog_closed as not needed with blocking exec

    def _on_shop_item_added(self, location, item_name):
        # Add to Items Widget
        self.items_widget.add_item(location, item_name)
        # Future: Update StateManager if needed?



class PersistentDockWidget(QDockWidget):
    """
    A DockWidget that doesn't delete itself on close, 
    but instead un-floats (docks back) or hides.
    User requested: 'on close reintegrate into main window'.
    """
    def __init__(self, title, parent=None):
        super().__init__(title, parent)
        # Set custom title bar for "Pin" functionality
        self.title_bar = DockTitleBar(title, self)
        self.setTitleBarWidget(self.title_bar)
        
        self.current_font_size = 11 # Default
        
        # Border Style (Global for the dock)
        self.setStyleSheet(f"""
            QDockWidget {{
                border: 1px solid #444; 
                titlebar-close-icon: url(none);
                titlebar-normal-icon: url(none);
            }}
            QWidget {{ font-size: {self.current_font_size}px; }}
        """)

    def adjust_font_size(self, delta):
        self.current_font_size += delta
        if self.current_font_size < 8: self.current_font_size = 8
        if self.current_font_size > 24: self.current_font_size = 24
        
        # Apply to children via stylesheet (generic fallback)
        self.setStyleSheet(f"""
            QDockWidget {{
                border: 1px solid #444;
            }}
            QWidget {{ font-size: {self.current_font_size}px; }}
        """)
        
        # Try specific update method for known widgets
        widget = self.widget()
        if widget and hasattr(widget, "set_content_font_size"):
             widget.set_content_font_size(self.current_font_size)

    def closeEvent(self, event):
        if self.isFloating():
            # If floating, 'restore' it to the dock area instead of hiding
            self.setFloating(False)
            event.ignore() # Prevent the default close (hide) event/deletion
        else:
            # If already docked and user clicks X, standard behavior is Hide.
            # We can allow hide, or ignore if we want them 'undeletable'. 
            # Let's allow hide so they can clear clutter, but they can re-open via View menu (TODO).
            super().closeEvent(event)
